(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Ppath2D"] = factory();
	else
		root["Ppath2D"] = factory();
})(this || (typeof window !== 'undefined' ? window : global), function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/Path.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/ModuleBase.js":
/*!***************************!*\
  !*** ./src/ModuleBase.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar ModuleBase =\n/*#__PURE__*/\nfunction () {\n  function ModuleBase(name) {\n    _classCallCheck(this, ModuleBase);\n\n    this.moduleBase = {\n      name: name || 'No module base name.'\n    };\n  }\n\n  _createClass(ModuleBase, [{\n    key: \"each\",\n    value: function each(target, callback) {\n      if (_typeof(target) === 'object') {\n        if (Array.isArray(target)) {\n          var len = target.length;\n\n          for (var i = 0; i < len; i++) {\n            var br = callback(target[i], i);\n\n            if (br === '_break') {\n              break;\n            }\n\n            if (br === '_continue') {\n              continue;\n            }\n          }\n        } else {\n          for (var key in target) {\n            var _br = callback(target[key], key);\n\n            if (_br === '_break') {\n              break;\n            }\n\n            if (_br === '_continue') {\n              continue;\n            }\n          }\n        }\n      } else {\n        this.systemError('each', 'Not a object or array.', target);\n      }\n    }\n  }, {\n    key: \"systemError\",\n    value: function systemError(functionName, message, object) {\n      if (object) {\n        console.log(\"%c error object is : \", 'color:#FFF; background:red');\n        console.log(object);\n      }\n\n      throw new Error(\"(\\u2609\\u0434\\u2299)!! \".concat(this.moduleBase.name, \" => \").concat(functionName, \" -> \").concat(message));\n    }\n  }]);\n\n  return ModuleBase;\n}();\n\nmodule.exports = ModuleBase;\n\n//# sourceURL=webpack://Ppath2D/./src/ModuleBase.js?");

/***/ }),

/***/ "./src/Path.js":
/*!*********************!*\
  !*** ./src/Path.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar ModuleBase = __webpack_require__(/*! ./ModuleBase */ \"./src/ModuleBase.js\");\n\nvar Path =\n/*#__PURE__*/\nfunction (_ModuleBase) {\n  _inherits(Path, _ModuleBase);\n\n  function Path(data, mode) {\n    var _this;\n\n    _classCallCheck(this, Path);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Path).call(this, 'Path'));\n    _this.points = [];\n    _this.length = 0;\n    _this.cacheMode = false;\n    _this.siteCaches = [];\n    _this.lengthCaches = [];\n\n    if (data) {\n      var type = _typeof(data);\n\n      if (type === 'string') {\n        _this.compile(data.trim(), mode);\n      }\n    }\n\n    return _this;\n  }\n\n  _createClass(Path, [{\n    key: \"setCache\",\n    value: function setCache(enable) {\n      this.cacheMode = !!enable;\n      this.siteCaches = [];\n    }\n  }, {\n    key: \"compile\",\n    value: function compile(data) {\n      var _this2 = this;\n\n      var mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'path';\n      var list = {\n        a: 'arc',\n        m: 'moveTo',\n        l: 'lineTo',\n        h: 'horizontalLineTo',\n        v: 'verticalLineTo',\n        c: 'curve',\n        q: 'quadraticBezierCurve',\n        s: 'smoothCurve',\n        t: 'smoothQuadraticBezierCurve',\n        z: 'closePath'\n      };\n\n      if (mode === 'path') {\n        var keys = Object.keys(list);\n        var index = -1;\n        var params = [''];\n\n        for (var i = 0; i < data.length; i++) {\n          if (/[a-zA-z]/.test(data[i])) {\n            index += 1;\n            params[index] = '';\n          }\n\n          if (data[i] === '-') {\n            params[index] += ' ';\n          }\n\n          params[index] += data[i];\n        }\n\n        this.each(params, function (param) {\n          var pt = param.trim();\n          var key = pt.slice(0, 1);\n          var data = pt.slice(1).split(/,|\\s/).filter(function (t) {\n            return t !== '';\n          }).map(function (d) {\n            return Number(d);\n          });\n\n          if (keys.indexOf(key.toLowerCase()) !== -1) {\n            if (/[a-z]/.test(key)) {\n              _this2[list[key.toLowerCase()]].apply(_this2, _toConsumableArray(data).concat([false]));\n            } else {\n              _this2[list[key.toLowerCase()]].apply(_this2, _toConsumableArray(data).concat([true]));\n            }\n          } else {\n            _this2.systemError('compile', 'Key name not found', key);\n          }\n        });\n      } else if (mode === 'polygon') {\n        this.readPolyline(data);\n        this.closePath();\n      } else if (mode === 'polyline') {\n        this.readPolyline(data);\n      }\n    }\n  }, {\n    key: \"readPolyline\",\n    value: function readPolyline(data) {\n      var params = '';\n\n      for (var i = 0; i < data.length; i++) {\n        if (data[i] === '-') {\n          params += ' ';\n        }\n\n        params += data[i];\n      }\n\n      data = params.split(/,|\\s/).filter(function (t) {\n        return t !== '';\n      }).map(function (d) {\n        return Number(d);\n      });\n      this.moveTo(data[0], data[1], true);\n\n      for (var _i = 2; _i < data.length; _i += 2) {\n        this.lineTo(data[_i], data[_i + 1], true);\n      }\n    }\n  }, {\n    key: \"eachPoint\",\n    value: function eachPoint(callback) {\n      var len = this.points.length;\n\n      for (var i = 0; i < len; i++) {\n        callback(this.points[i]);\n      }\n    }\n  }, {\n    key: \"addPoint\",\n    value: function addPoint(point) {\n      if (point.error) {\n        this.systemError('addPoint', point.error, point);\n      }\n\n      this.lengthCaches.push(this.length);\n      this.points.push(point);\n      this.length += point.length;\n    }\n  }, {\n    key: \"addPath\",\n    value: function addPath(path) {\n      if (path instanceof Path) {\n        this.compile(path.toPathString());\n      } else {\n        this.systemError('addPath', 'Object not a Ppath2D data.', path);\n      }\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this3 = this;\n\n      this.length = 0;\n      this.siteCaches = [];\n      this.lengthCaches = [];\n      this.eachPoint(function (point) {\n        _this3.lengthCaches.push(_this3.length);\n\n        _this3.length += point.length;\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(context) {\n      context.beginPath();\n      this.eachPoint(function (point) {\n        point.render(context);\n      });\n    }\n  }, {\n    key: \"toPathString\",\n    value: function toPathString() {\n      var string = '';\n      this.eachPoint(function (point) {\n        string += point.toPathString();\n      });\n      return string;\n    }\n  }, {\n    key: \"getLastPoint\",\n    value: function getLastPoint() {\n      return this.points.length === 0 ? {\n        ex: 0,\n        ey: 0\n      } : this.points.slice(-1)[0];\n    }\n  }, {\n    key: \"getLastPosition\",\n    value: function getLastPosition() {\n      var p = this.points[this.points.length - 1];\n      return p ? p.getLastPosition() : {\n        x: 0,\n        y: 0\n      };\n    }\n  }, {\n    key: \"getLinePosition\",\n    value: function getLinePosition(t) {\n      if (this.cacheMode && this.siteCaches[t]) {\n        return this.siteCaches[t];\n      }\n\n      var target = null;\n      var site = null;\n      var dis = this.length * t;\n      var len = this.points.length;\n      var index = 0;\n\n      if (this.lengthCaches.length > 10) {\n        var range = 10;\n        var length = Math.floor(this.lengthCaches.length * (1 / range));\n\n        for (var i = 1; i < range; i++) {\n          if (dis <= this.lengthCaches[i * length]) {\n            break;\n          }\n\n          index = (i - 1) * length;\n        }\n\n        dis -= this.lengthCaches[index];\n      }\n\n      for (var _i2 = index; _i2 < len; _i2++) {\n        if (dis <= this.points[_i2].length) {\n          if (this.points[_i2]) {\n            target = this.points[_i2];\n            break;\n          }\n        } else {\n          dis -= this.points[_i2].length;\n        }\n      }\n\n      if (target) {\n        site = target.getLinePosition(dis / target.length);\n      } else {\n        site = this.getLastPosition();\n      }\n\n      if (this.cacheMode && this.siteCaches.length <= 2000) {\n        this.siteCaches[t] = site;\n      }\n\n      return site;\n    }\n  }, {\n    key: \"getDirection\",\n    value: function getDirection(t) {\n      var to = t + 0.01;\n      var p1 = this.getLinePosition(t);\n      var p2 = this.getLinePosition(to);\n      return Supports.getAngle(p1.x, p1.y, p2.x, p2.y) - 270;\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo(x, y) {\n      var abs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this.addPoint(new PointBase.MoveTo(this, this.getLastPoint(), x, y, abs));\n      return this;\n    }\n  }, {\n    key: \"lineTo\",\n    value: function lineTo(x, y) {\n      var abs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this.addPoint(new PointBase.LineTo(this, this.getLastPoint(), x, y, abs));\n      return this;\n    }\n  }, {\n    key: \"curve\",\n    value: function curve(x1, y1, x2, y2, x, y) {\n      var abs = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n      this.addPoint(new PointBase.Curve(this, this.getLastPoint(), x1, y1, x2, y2, x, y, abs));\n      return this;\n    }\n  }, {\n    key: \"quadraticBezierCurve\",\n    value: function quadraticBezierCurve(x1, y1, x, y) {\n      var abs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      this.addPoint(new PointBase.QuadraticBezierCurve(this, this.getLastPoint(), x1, y1, x, y, abs));\n      return this;\n    }\n  }, {\n    key: \"smoothCurve\",\n    value: function smoothCurve(x2, y2, x, y) {\n      var abs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      this.addPoint(new PointBase.SmoothCurve(this, this.getLastPoint(), x2, y2, x, y, abs));\n      return this;\n    }\n  }, {\n    key: \"smoothQuadraticBezierCurve\",\n    value: function smoothQuadraticBezierCurve(x, y) {\n      var abs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this.addPoint(new PointBase.SmoothQuadraticBezierCurve(this, this.getLastPoint(), x, y, abs));\n      return this;\n    }\n  }, {\n    key: \"horizontalLineTo\",\n    value: function horizontalLineTo(x) {\n      var abs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.addPoint(new PointBase.HorizontalLineTo(this, this.getLastPoint(), x, abs));\n      return this;\n    }\n  }, {\n    key: \"verticalLineTo\",\n    value: function verticalLineTo(y) {\n      var abs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.addPoint(new PointBase.VerticalLineTo(this, this.getLastPoint(), y, abs));\n      return this;\n    }\n  }, {\n    key: \"arc\",\n    value: function arc(rx, ry, rotation, large, sweep, x, y) {\n      var abs = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;\n      this.addPoint(new PointBase.Arc(this, this.getLastPoint(), rx, ry, rotation, large, sweep, x, y, abs));\n      return this;\n    }\n  }, {\n    key: \"closePath\",\n    value: function closePath() {\n      var target = this.points.filter(function (p) {\n        return p instanceof PointBase.MoveTo;\n      }).pop();\n      this.addPoint(new PointBase.ClosePath(this, this.getLastPoint(), target));\n      return this;\n    }\n  }]);\n\n  return Path;\n}(ModuleBase);\n\nvar Supports =\n/*#__PURE__*/\nfunction () {\n  function Supports() {\n    _classCallCheck(this, Supports);\n  }\n\n  _createClass(Supports, null, [{\n    key: \"getDistance\",\n    value: function getDistance(x, y, ax, ay) {\n      return Math.sqrt(Math.pow(ax - x, 2) + Math.pow(ay - y, 2));\n    }\n  }, {\n    key: \"getAngle\",\n    value: function getAngle(x, y, ax, ay) {\n      if (x === ax && y === ay) {\n        return 0;\n      }\n\n      var angle = Math.atan2(ay - y, ax - x) * 180 / Math.PI;\n      return angle > 0 ? angle : 360 + angle;\n    }\n  }, {\n    key: \"getSvgLength\",\n    value: function getSvgLength(d) {\n      var pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n      pathElement.setAttributeNS(null, 'd', d);\n      return pathElement.getTotalLength();\n    }\n  }]);\n\n  return Supports;\n}();\n\nvar PointBase =\n/*#__PURE__*/\nfunction () {\n  function PointBase(path, parent) {\n    var absolute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, PointBase);\n\n    this.error = null;\n    this.initData();\n    this.resetReference(path, parent);\n    this.offset = {\n      x: 0,\n      y: 0\n    };\n    this.absolute = !!absolute;\n    this._absolute = !!absolute;\n  }\n\n  _createClass(PointBase, [{\n    key: \"resetReference\",\n    value: function resetReference(path, parent) {\n      this.path = path;\n      this.parent = parent || this.parent;\n    }\n  }, {\n    key: \"initData\",\n    value: function initData() {\n      this.length = 0;\n      this.data = {\n        p1x: 0,\n        p1y: 0,\n        p2x: 0,\n        p2y: 0,\n        ex: 0,\n        ey: 0\n      };\n    }\n  }, {\n    key: \"resetData\",\n    value: function resetData(options) {\n      var refreshPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      for (var key in options) {\n        if (this.data[key] != null) {\n          this[key] = options[key];\n        }\n      }\n\n      this.refresh(refreshPath);\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh(refreshPath) {\n      this.length = this.getLength();\n\n      if (refreshPath) {\n        this.path.refreshLength();\n      }\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return 0;\n    }\n  }, {\n    key: \"getLastPosition\",\n    value: function getLastPosition() {\n      return {\n        x: this.ex,\n        y: this.ey\n      };\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return this.toPathString().trim()[0];\n    }\n  }, {\n    key: \"absolute\",\n    set: function set(absolute) {\n      this._absolute = !!absolute;\n      this.offset.x = absolute ? 0 : this.sx;\n      this.offset.y = absolute ? 0 : this.sy;\n    }\n  }, {\n    key: \"sx\",\n    get: function get() {\n      return this.parent.ex;\n    }\n  }, {\n    key: \"sy\",\n    get: function get() {\n      return this.parent.ey;\n    }\n  }, {\n    key: \"ex\",\n    get: function get() {\n      return this.data.ex + this.offset.x;\n    },\n    set: function set(val) {\n      this.data.ex = val;\n    }\n  }, {\n    key: \"ey\",\n    get: function get() {\n      return this.data.ey + this.offset.y;\n    },\n    set: function set(val) {\n      this.data.ey = val;\n    }\n  }, {\n    key: \"p1x\",\n    get: function get() {\n      return this.data.p1x + this.offset.x;\n    },\n    set: function set(val) {\n      this.data.p1x = val;\n    }\n  }, {\n    key: \"p1y\",\n    get: function get() {\n      return this.data.p1y + this.offset.y;\n    },\n    set: function set(val) {\n      this.data.p1y = val;\n    }\n  }, {\n    key: \"p2x\",\n    get: function get() {\n      return this.data.p2x + this.offset.x;\n    },\n    set: function set(val) {\n      this.data.p2x = val;\n    }\n  }, {\n    key: \"p2y\",\n    get: function get() {\n      return this.data.p2y + this.offset.y;\n    },\n    set: function set(val) {\n      this.data.p2y = val;\n    }\n  }]);\n\n  return PointBase;\n}();\n\nPointBase.MoveTo =\n/*#__PURE__*/\nfunction (_PointBase) {\n  _inherits(_class, _PointBase);\n\n  function _class(path, parent, x, y, absolute) {\n    var _this4;\n\n    _classCallCheck(this, _class);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this, path, parent, absolute));\n\n    _this4.resetData({\n      ex: x,\n      ey: y\n    });\n\n    return _this4;\n  }\n\n  _createClass(_class, [{\n    key: \"render\",\n    value: function render(context) {\n      context.moveTo(this.ex, this.ey);\n    }\n  }, {\n    key: \"toPathString\",\n    value: function toPathString() {\n      return \"M\".concat(this.ex, \",\").concat(this.ey);\n    }\n  }, {\n    key: \"getLinePosition\",\n    value: function getLinePosition() {\n      return {\n        x: this.ex,\n        y: this.ey\n      };\n    }\n  }, {\n    key: \"getPositionX\",\n    value: function getPositionX() {\n      return this.ex;\n    }\n  }, {\n    key: \"getPositionY\",\n    value: function getPositionY() {\n      return this.ey;\n    }\n  }]);\n\n  return _class;\n}(PointBase);\n\nPointBase.LineTo =\n/*#__PURE__*/\nfunction (_PointBase2) {\n  _inherits(_class2, _PointBase2);\n\n  function _class2(path, parent, x, y, absolute) {\n    var _this5;\n\n    _classCallCheck(this, _class2);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(_class2).call(this, path, parent, absolute));\n\n    _this5.resetData({\n      ex: x,\n      ey: y\n    });\n\n    return _this5;\n  }\n\n  _createClass(_class2, [{\n    key: \"render\",\n    value: function render(context) {\n      context.lineTo(this.ex, this.ey);\n    }\n  }, {\n    key: \"toPathString\",\n    value: function toPathString() {\n      return \"L\".concat(this.ex, \",\").concat(this.ey);\n    }\n  }, {\n    key: \"getLinePosition\",\n    value: function getLinePosition(t) {\n      return {\n        x: this.sx * (1 - t) + this.ex * t,\n        y: this.sy * (1 - t) + this.ey * t\n      };\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      return Supports.getDistance(this.sx, this.sy, this.ex, this.ey);\n    }\n  }]);\n\n  return _class2;\n}(PointBase);\n\nPointBase.HorizontalLineTo =\n/*#__PURE__*/\nfunction (_PointBase$LineTo) {\n  _inherits(_class3, _PointBase$LineTo);\n\n  function _class3(path, parent, x, absolute) {\n    _classCallCheck(this, _class3);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(_class3).call(this, path, parent, x, absolute ? parent.ey : 0, absolute));\n  }\n\n  _createClass(_class3, [{\n    key: \"toPathString\",\n    value: function toPathString() {\n      return \"H\".concat(this.ex);\n    }\n  }]);\n\n  return _class3;\n}(PointBase.LineTo);\n\nPointBase.VerticalLineTo =\n/*#__PURE__*/\nfunction (_PointBase$LineTo2) {\n  _inherits(_class4, _PointBase$LineTo2);\n\n  function _class4(path, parent, y, absolute) {\n    _classCallCheck(this, _class4);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(_class4).call(this, path, parent, absolute ? parent.ex : 0, y, absolute));\n  }\n\n  _createClass(_class4, [{\n    key: \"toPathString\",\n    value: function toPathString() {\n      return \"V\".concat(this.ey);\n    }\n  }]);\n\n  return _class4;\n}(PointBase.LineTo);\n\nPointBase.Curve =\n/*#__PURE__*/\nfunction (_PointBase3) {\n  _inherits(_class5, _PointBase3);\n\n  function _class5(path, parent, x1, y1, x2, y2, x, y) {\n    var _this6;\n\n    var absolute = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;\n\n    _classCallCheck(this, _class5);\n\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(_class5).call(this, path, parent, absolute));\n\n    _this6.resetData({\n      p1x: x1,\n      p1y: y1,\n      p2x: x2,\n      p2y: y2,\n      ex: x,\n      ey: y\n    });\n\n    return _this6;\n  }\n\n  _createClass(_class5, [{\n    key: \"getStep\",\n    value: function getStep() {\n      return 100;\n    }\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(t, s, p1, p2, e) {\n      return s * (1 - t) * (1 - t) * (1 - t) + 3 * p1 * (1 - t) * (1 - t) * t + 3 * p2 * (1 - t) * t * t + e * t * t * t;\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      if (Compatibility.GeometryElement) {\n        return Supports.getSvgLength(\"M\".concat(this.sx, \",\").concat(this.sy) + this.toPathString());\n      }\n\n      var x = 0;\n      var y = 0;\n      var t = 0;\n      var length = 0;\n      var steps = this.getStep();\n      var previousDotX = 0;\n      var previousDotY = 0;\n\n      for (var i = 0; i <= steps; i++) {\n        t = i / steps;\n        x = this.getPoint(t, this.sx, this.p1x, this.p2x, this.ex);\n        y = this.getPoint(t, this.sy, this.p1y, this.p2y, this.ey);\n\n        if (i > 0) {\n          var diffX = x - previousDotX;\n          var diffY = y - previousDotY;\n          length += Math.sqrt(diffX * diffX + diffY * diffY);\n        }\n\n        previousDotX = x;\n        previousDotY = y;\n      }\n\n      return length;\n    }\n  }, {\n    key: \"render\",\n    value: function render(context) {\n      context.bezierCurveTo(this.p1x, this.p1y, this.p2x, this.p2y, this.ex, this.ey);\n    }\n  }, {\n    key: \"toPathString\",\n    value: function toPathString() {\n      return \"C\".concat(this.p1x, \",\").concat(this.p1y, \",\").concat(this.p2x, \",\").concat(this.p2y, \",\").concat(this.ex, \",\").concat(this.ey);\n    }\n  }, {\n    key: \"getLinePosition\",\n    value: function getLinePosition(t) {\n      return {\n        x: this.getPoint(t, this.sx, this.p1x, this.p2x, this.ex),\n        y: this.getPoint(t, this.sy, this.p1y, this.p2y, this.ey)\n      };\n    }\n  }]);\n\n  return _class5;\n}(PointBase);\n\nPointBase.QuadraticBezierCurve =\n/*#__PURE__*/\nfunction (_PointBase$Curve) {\n  _inherits(_class6, _PointBase$Curve);\n\n  function _class6(path, parent, p1x, p1y, ex, ey) {\n    var absolute = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n\n    _classCallCheck(this, _class6);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(_class6).call(this, path, parent, p1x, p1y, p1x, p1y, ex, ey, absolute));\n  }\n\n  _createClass(_class6, [{\n    key: \"render\",\n    value: function render(context) {\n      context.quadraticCurveTo(this.p1x, this.p1y, this.ex, this.ey);\n    }\n  }, {\n    key: \"toPathString\",\n    value: function toPathString() {\n      return \"Q\".concat(this.p1x, \",\").concat(this.p1y, \",\").concat(this.ex, \",\").concat(this.ey);\n    }\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(t, s, p1, p2, e) {\n      return (1 - t) * (1 - t) * s + 2 * t * (1 - t) * p1 + t * t * e;\n    }\n  }, {\n    key: \"p2x\",\n    get: function get() {\n      return this.p1x;\n    },\n    set: function set(val) {\n      this.data.p2x = val;\n    }\n  }, {\n    key: \"p2y\",\n    get: function get() {\n      return this.p1y;\n    },\n    set: function set(val) {\n      this.data.p2y = val;\n    }\n  }]);\n\n  return _class6;\n}(PointBase.Curve);\n\nPointBase.SmoothCurve =\n/*#__PURE__*/\nfunction (_PointBase$Curve2) {\n  _inherits(_class7, _PointBase$Curve2);\n\n  function _class7(path, parent, p2x, p2y, ex, ey) {\n    var absolute = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n\n    _classCallCheck(this, _class7);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(_class7).call(this, path, parent, 0, 0, p2x, p2y, ex, ey, absolute));\n  }\n\n  _createClass(_class7, [{\n    key: \"render\",\n    value: function render(context) {\n      context.bezierCurveTo(this.p1x, this.p1y, this.p2x, this.p2y, this.ex, this.ey);\n    }\n  }, {\n    key: \"toPathString\",\n    value: function toPathString() {\n      return \"S\".concat(this.p2x, \",\").concat(this.p2y, \",\").concat(this.ex, \",\").concat(this.ey);\n    }\n  }, {\n    key: \"parentIsCurve\",\n    get: function get() {\n      return !!this.parent.getType().toLowerCase().match(/q|c|s|t/);\n    }\n  }, {\n    key: \"p1x\",\n    get: function get() {\n      return this.parentIsCurve ? this.parent.ex * 2 - this.parent.p2x : this.p2x;\n    },\n    set: function set(val) {\n      this.data.p1x = val;\n    }\n  }, {\n    key: \"p1y\",\n    get: function get() {\n      return this.parentIsCurve ? this.parent.ey * 2 - this.parent.p2y : this.p2y;\n    },\n    set: function set(val) {\n      this.data.p1y = val;\n    }\n  }]);\n\n  return _class7;\n}(PointBase.Curve);\n\nPointBase.SmoothQuadraticBezierCurve =\n/*#__PURE__*/\nfunction (_PointBase$Curve3) {\n  _inherits(_class8, _PointBase$Curve3);\n\n  function _class8(path, parent, ex, ey) {\n    var _this7;\n\n    var absolute = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    _classCallCheck(this, _class8);\n\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(_class8).call(this, path, parent, 0, 0, 0, 0, ex, ey, absolute));\n\n    if (parent.getType().toLowerCase() !== 'q') {\n      _this7.error = 'Smooth Quadratic BezierCurve previous point must a Quadratic Bezier Curve.';\n    }\n\n    return _this7;\n  }\n\n  _createClass(_class8, [{\n    key: \"render\",\n    value: function render(context) {\n      context.quadraticCurveTo(this.p1x, this.p1y, this.ex, this.ey);\n    }\n  }, {\n    key: \"toPathString\",\n    value: function toPathString() {\n      return \"T\".concat(this.ex, \",\").concat(this.ey);\n    }\n  }, {\n    key: \"getPoint\",\n    value: function getPoint(t, s, p1, p2, e) {\n      return (1 - t) * (1 - t) * s + 2 * t * (1 - t) * p1 + t * t * e;\n    }\n  }, {\n    key: \"p2x\",\n    get: function get() {\n      return this.p1x;\n    },\n    set: function set(val) {}\n  }, {\n    key: \"p2y\",\n    get: function get() {\n      return this.p1y;\n    },\n    set: function set(val) {}\n  }, {\n    key: \"p1x\",\n    get: function get() {\n      return this.parent.ex * 2 - this.parent.p1x;\n    },\n    set: function set(val) {}\n  }, {\n    key: \"p1y\",\n    get: function get() {\n      return this.parent.ey * 2 - this.parent.p1y;\n    },\n    set: function set(val) {}\n  }]);\n\n  return _class8;\n}(PointBase.Curve);\n\nPointBase.Arc =\n/*#__PURE__*/\nfunction (_PointBase4) {\n  _inherits(_class9, _PointBase4);\n\n  function _class9(path, parent, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {\n    var _this8;\n\n    var absolute = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;\n\n    _classCallCheck(this, _class9);\n\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(_class9).call(this, path, parent, absolute));\n    _this8.rx = rx;\n    _this8.ry = ry;\n    _this8.sweepFlag = sweepFlag;\n    _this8.largeArcFlag = largeArcFlag;\n    _this8.xAxisRotation = xAxisRotation;\n\n    _this8.resetData({\n      ex: x,\n      ey: y\n    });\n\n    return _this8;\n  }\n\n  _createClass(_class9, [{\n    key: \"resetData\",\n    value: function resetData(options) {\n      this.rx = options.rx ? options.rx : this.rx;\n      this.ry = options.ry ? options.ry : this.ry;\n      this.sweepFlag = options.sweepFlag ? options.sweepFlag : this.sweepFlag;\n      this.largeArcFlag = options.largeArcFlag ? options.largeArcFlag : this.largeArcFlag;\n      this.xAxisRotation = options.xAxisRotation ? options.xAxisRotation : this.xAxisRotation;\n\n      _get(_getPrototypeOf(_class9.prototype), \"resetData\", this).call(this, options);\n    }\n  }, {\n    key: \"getStep\",\n    value: function getStep() {\n      return 100;\n    }\n  }, {\n    key: \"render\",\n    value: function render(context) {\n      var steps = this.getStep();\n\n      for (var i = 0; i < steps; i += 1) {\n        var p = this.getLinePosition(i / steps);\n        context.lineTo(p.x, p.y);\n      }\n    }\n  }, {\n    key: \"toPathString\",\n    value: function toPathString() {\n      return \"A\".concat(this.rx, \",\").concat(this.ry, \",\").concat(this.xAxisRotation, \",\").concat(this.largeArcFlag, \",\").concat(this.sweepFlag, \",\").concat(this.ex, \",\").concat(this.ey);\n    }\n  }, {\n    key: \"angleBetween\",\n    value: function angleBetween(v0, v1) {\n      var p = v0.x * v1.x + v0.y * v1.y;\n      var n = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));\n      var sign = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;\n      var angle = sign * Math.acos(p / n);\n      return angle;\n    }\n  }, {\n    key: \"getLinePosition\",\n    value: function getLinePosition(per) {\n      var rx = Math.abs(this.rx);\n      var ry = Math.abs(this.ry);\n      var prx = Math.pow(rx, 2);\n      var pry = Math.pow(ry, 2);\n      var xAxisRotationRadians = this.xAxisRotation % 360 * (Math.PI / 180);\n      var xAxisRotationRadiansCos = Math.cos(xAxisRotationRadians);\n      var xAxisRotationRadiansSin = Math.sin(xAxisRotationRadians);\n\n      if (this.sx === this.ex && this.sy === this.ey) {\n        return {\n          x: this.sx,\n          y: this.sy\n        };\n      }\n\n      if (rx === 0 || ry === 0) {\n        return {\n          x: this.sx * (1 - per) + this.ex * per,\n          y: this.sy * (1 - per) + this.ey * per\n        };\n      }\n\n      var dx = (this.sx - this.ex) / 2;\n      var dy = (this.sy - this.ey) / 2;\n      var transformedPoint = {\n        x: xAxisRotationRadiansCos * dx + xAxisRotationRadiansSin * dy,\n        y: -xAxisRotationRadiansSin * dx + xAxisRotationRadiansCos * dy\n      };\n      var pTransformedPointX = Math.pow(transformedPoint.x, 2);\n      var pTransformedPointY = Math.pow(transformedPoint.y, 2);\n      var radiiCheck = pTransformedPointX / prx + pTransformedPointY / pry;\n\n      if (radiiCheck > 1) {\n        var radiiCheckSqrt = Math.sqrt(radiiCheck);\n        rx = radiiCheckSqrt * rx;\n        ry = radiiCheckSqrt * ry;\n      }\n\n      var cSquareNumerator = prx * pry - prx * pTransformedPointY - pry * pTransformedPointX;\n      var cSquareRootDenom = prx * pTransformedPointY + pry * pTransformedPointX;\n      var cRadicand = cSquareNumerator / cSquareRootDenom;\n      cRadicand = cRadicand < 0 ? 0 : cRadicand;\n      var cCoef = (this.largeArcFlag !== this.sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);\n      var transformedCenter = {\n        x: cCoef * (rx * transformedPoint.y / ry),\n        y: cCoef * (-(ry * transformedPoint.x) / rx)\n      };\n      var center = {\n        x: xAxisRotationRadiansCos * transformedCenter.x - xAxisRotationRadiansSin * transformedCenter.y + (this.sx + this.ex) / 2,\n        y: xAxisRotationRadiansSin * transformedCenter.x + xAxisRotationRadiansCos * transformedCenter.y + (this.sy + this.ey) / 2\n      };\n      var startVector = {\n        x: (transformedPoint.x - transformedCenter.x) / rx,\n        y: (transformedPoint.y - transformedCenter.y) / ry\n      };\n      var startAngle = this.angleBetween({\n        x: 1,\n        y: 0\n      }, startVector);\n      var endVector = {\n        x: (-transformedPoint.x - transformedCenter.x) / rx,\n        y: (-transformedPoint.y - transformedCenter.y) / ry\n      };\n      var sweepAngle = this.angleBetween(startVector, endVector);\n      var cir = 2 * Math.PI;\n\n      if (!this.sweepFlag && sweepAngle > 0) {\n        sweepAngle -= cir;\n      } else if (this.sweepFlag && sweepAngle < 0) {\n        sweepAngle += cir;\n      }\n\n      sweepAngle %= cir;\n      var angle = startAngle + sweepAngle * per;\n      var ellipseComponentX = rx * Math.cos(angle);\n      var ellipseComponentY = ry * Math.sin(angle);\n      return {\n        x: xAxisRotationRadiansCos * ellipseComponentX - xAxisRotationRadiansSin * ellipseComponentY + center.x,\n        y: xAxisRotationRadiansSin * ellipseComponentX + xAxisRotationRadiansCos * ellipseComponentY + center.y\n      };\n    }\n  }, {\n    key: \"getDistance\",\n    value: function getDistance(p1, p2) {\n      return Supports.getDistance(p1.x, p1.y, p2.x, p2.y);\n    }\n  }, {\n    key: \"getLength\",\n    value: function getLength() {\n      if (Compatibility.GeometryElement) {\n        return Supports.getSvgLength(\"M\".concat(this.sx, \",\").concat(this.sy) + this.toPathString());\n      }\n\n      var steps = this.getStep();\n      var resultantArcLength = 0;\n      var prevPoint = this.getLinePosition(0);\n      var nextPoint;\n\n      for (var i = 0; i < steps; i++) {\n        var t = Math.min(Math.max(i * (1 / steps), 0), 1);\n        nextPoint = this.getLinePosition(t);\n        resultantArcLength += this.getDistance(prevPoint, nextPoint);\n        prevPoint = nextPoint;\n      }\n\n      nextPoint = this.getLinePosition(1);\n      resultantArcLength += this.getDistance(prevPoint, nextPoint);\n      return resultantArcLength;\n    }\n  }]);\n\n  return _class9;\n}(PointBase);\n\nPointBase.ClosePath =\n/*#__PURE__*/\nfunction (_PointBase$LineTo3) {\n  _inherits(_class10, _PointBase$LineTo3);\n\n  function _class10(path, parent, target) {\n    _classCallCheck(this, _class10);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(_class10).call(this, path, parent, target.ex, target.ey, target.absolute));\n  }\n\n  _createClass(_class10, [{\n    key: \"render\",\n    value: function render(context) {\n      context.closePath();\n    }\n  }, {\n    key: \"toPathString\",\n    value: function toPathString() {\n      return 'z';\n    }\n  }]);\n\n  return _class10;\n}(PointBase.LineTo);\n\nvar Compatibility = {\n  Path2D: !!Path2D,\n  GeometryElement: function () {\n    try {\n      Supports.getSvgLength('M0,0');\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }()\n};\nmodule.exports = Path;\n\n//# sourceURL=webpack://Ppath2D/./src/Path.js?");

/***/ })

/******/ });
});